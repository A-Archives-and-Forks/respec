// @ts-check
/*jshint
    forin: false
*/

// Module w3c/headers
// Generate the headers material based on the provided configuration.
// CONFIGURATION
//  - specStatus: the short code for the specification's maturity level or type (required)
//  - shortName: the small name that is used after /TR/ in published reports (required)
//  - editors: an array of people editing the document (at least one is required). People
//      are defined using:
//          - name: the person's name (required)
//          - url: URI for the person's home page
//          - company: the person's company
//          - companyURL: the URI for the person's company
//          - mailto: the person's email
//          - note: a note on the person (e.g. former editor)
//  - authors: an array of people who are contributing authors of the document.
//  - formerEditors: an array of people that had earlier edited the document but no longer edit.
//  - subtitle: a subtitle for the specification
//  - publishDate: the date to use for the publication, default to document.lastModified, and
//      failing that to now. The format is YYYY-MM-DD or a Date object.
//  - previousPublishDate: the date on which the previous version was published.
//  - previousMaturity: the specStatus of the previous version
//  - errata: the URI of the errata document, if any
//  - alternateFormats: a list of alternate formats for the document, each of which being
//      defined by:
//          - uri: the URI to the alternate
//          - label: a label for the alternate
//          - lang: optional language
//          - type: optional MIME type
//  - logos: a list of logos to use instead of the W3C logo, each of which being defined by:
//          - src: the URI to the logo (target of <img src=>)
//          - alt: alternate text for the image (<img alt=>), defaults to "Logo" or "Logo 1", "Logo 2", ...
//            if src is not specified, this is the text of the "logo"
//          - height: optional height of the logo (<img height=>)
//          - width: optional width of the logo (<img width=>)
//          - url: the URI to the organization represented by the logo (target of <a href=>)
//          - id: optional id for the logo, permits custom CSS (wraps logo in <span id=>)
//          - each logo element must specifiy either src or alt
//  - testSuiteURI: the URI to the test suite, if any
//  - implementationReportURI: the URI to the implementation report, if any
//  - bugTracker: and object with the following details
//      - open: pointer to the list of open bugs
//      - new: pointer to where to raise new bugs
//  - noRecTrack: set to true if this document is not intended to be on the Recommendation track
//  - edDraftURI: the URI of the Editor's Draft for this document, if any. Required if
//      specStatus is set to "ED".
//  - additionalCopyrightHolders: a copyright owner in addition to W3C (or the only one if specStatus
//      is unofficial)
//  - overrideCopyright: provides markup to completely override the copyright
//  - copyrightStart: the year from which the copyright starts running
//  - prevED: the URI of the previous Editor's Draft if it has moved
//  - prevRecShortname: the short name of the previous Recommendation, if the name has changed
//  - prevRecURI: the URI of the previous Recommendation if not directly generated from
//    prevRecShortname.
//  - wg: the name of the WG in charge of the document. This may be an array in which case wgURI
//      and wgPatentURI need to be arrays as well, of the same length and in the same order
//  - wgURI: the URI to the group's page, or an array of such
//  - wgPatentURI: the URI to the group's patent information page, or an array of such. NOTE: this
//      is VERY IMPORTANT information to provide and get right, do not just paste this without checking
//      that you're doing it right
//  - wgPublicList: the name of the mailing list where discussion takes place. Note that this cannot
//      be an array as it is assumed that there is a single list to discuss the document, even if it
//      is handled by multiple groups
//  - charterDisclosureURI: used for IGs (when publishing IG-NOTEs) to provide a link to the IPR commitment
//      defined in their charter.
//  - addPatentNote: used to add patent-related information to the SotD, for instance if there's an open
//      PAG on the document.
//  - thisVersion: the URI to the dated current version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - latestVersion: the URI to the latest (undated) version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - prevVersion: the URI to the previous (dated) version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - subjectPrefix: the string that is expected to be used as a subject prefix when posting to the mailing
//      list of the group.
//  - otherLinks: an array of other links that you might want in the header (e.g., link github, twitter, etc).
//         Example of usage: [{key: "foo", href:"https://b"}, {key: "bar", href:"https://"}].
//         Allowed values are:
//          - key: the key for the <dt> (e.g., "Bug Tracker"). Required.
//          - value: The value that will appear in the <dd> (e.g., "GitHub"). Optional.
//          - href: a URL for the value (e.g., "https://foo.com/issues"). Optional.
//          - class: a string representing CSS classes. Optional.
//  - license: can be one of the following
//      - "w3c", currently the default (restrictive) license
//      - "cc-by", which is experimentally available in some groups (but likely to be phased out).
//          Note that this is a dual licensing regime.
//      - "cc0", an extremely permissive license. It is only recommended if you are working on a document that is
//          intended to be pushed to the WHATWG.
//      - "w3c-software", a permissive and attributions license (but GPL-compatible).
//      - "w3c-software-doc", the W3C Software and Document License
//            https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
import { ISODate, concatDate, joinAnd } from "../core/utils";
import cgbgHeadersTmpl from "./templates/cgbg-headers";
import cgbgSotdTmpl from "./templates/cgbg-sotd";
import headersTmpl from "./templates/headers";
import hyperHTML from "hyperhtml";
import { pub } from "../core/pubsubhub";
import sotdTmpl from "./templates/sotd";

export const name = "w3c/headers";

const W3CDate = new Intl.DateTimeFormat(["en-AU"], {
  timeZone: "UTC",
  year: "numeric",
  month: "long",
  day: "2-digit",
});

const status2maturity = {
  LS: "WD",
  LD: "WD",
  FPWD: "WD",
  LC: "WD",
  FPLC: "WD",
  "FPWD-NOTE": "NOTE",
  "WD-NOTE": "WD",
  "LC-NOTE": "LC",
  "IG-NOTE": "NOTE",
  "WG-NOTE": "NOTE",
};

const status2rdf = {
  NOTE: "w3p:NOTE",
  WD: "w3p:WD",
  LC: "w3p:LastCall",
  CR: "w3p:CR",
  PR: "w3p:PR",
  REC: "w3p:REC",
  PER: "w3p:PER",
  RSCND: "w3p:RSCND",
};
const status2text = {
  NOTE: "Working Group Note",
  "WG-NOTE": "Working Group Note",
  "CG-NOTE": "Co-ordination Group Note",
  "IG-NOTE": "Interest Group Note",
  "Member-SUBM": "Member Submission",
  "Team-SUBM": "Team Submission",
  MO: "Member-Only Document",
  ED: "Editor's Draft",
  LS: "Living Standard",
  LD: "Living Document",
  FPWD: "First Public Working Draft",
  WD: "Working Draft",
  "FPWD-NOTE": "Working Group Note",
  "WD-NOTE": "Working Draft",
  "LC-NOTE": "Working Draft",
  FPLC: "First Public and Last Call Working Draft",
  LC: "Last Call Working Draft",
  CR: "Candidate Recommendation",
  PR: "Proposed Recommendation",
  PER: "Proposed Edited Recommendation",
  REC: "Recommendation",
  RSCND: "Rescinded Recommendation",
  unofficial: "Unofficial Draft",
  base: "Document",
  finding: "TAG Finding",
  "draft-finding": "Draft TAG Finding",
  "CG-DRAFT": "Draft Community Group Report",
  "CG-FINAL": "Final Community Group Report",
  "BG-DRAFT": "Draft Business Group Report",
  "BG-FINAL": "Final Business Group Report",
};
const status2long = {
  ...status2text,
  "FPWD-NOTE": "First Public Working Group Note",
  "LC-NOTE": "Last Call Working Draft",
};
const recTrackStatus = ["FPWD", "WD", "FPLC", "LC", "CR", "PR", "PER", "REC"];
const noTrackStatus = [
  "MO",
  "unofficial",
  "base",
  "finding",
  "draft-finding",
  "CG-DRAFT",
  "CG-FINAL",
  "BG-DRAFT",
  "BG-FINAL",
];
const cgbg = ["CG-DRAFT", "CG-FINAL", "BG-DRAFT", "BG-FINAL"];
const precededByAn = ["ED", "IG-NOTE"];
const licenses = {
  cc0: {
    name: "Creative Commons 0 Public Domain Dedication",
    short: "CC0",
    url: "https://creativecommons.org/publicdomain/zero/1.0/",
  },
  "w3c-software": {
    name: "W3C Software Notice and License",
    short: "W3C Software",
    url: "https://www.w3.org/Consortium/Legal/2002/copyright-software-20021231",
  },
  "w3c-software-doc": {
    name: "W3C Software and Document Notice and License",
    short: "W3C Software and Document",
    url:
      "https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document",
  },
  "cc-by": {
    name: "Creative Commons Attribution 4.0 International Public License",
    short: "CC-BY",
    url: "https://creativecommons.org/licenses/by/4.0/legalcode",
  },
};

const baseLogo = Object.freeze({
  id: "",
  alt: "",
  href: "",
  src: "",
  height: "48",
  width: "72",
});

function createTemplateOptions(conf) {
  const options = {
    get mailToWGPublicList() {
      return `mailto:${this.wgPublicList}@w3.org`;
    },
    get mailToWGPublicListWithSubject() {
      const fragment = this.subjectPrefix
        ? `?subject=${encodeURIComponent(this.subjectPrefix)}`
        : "";
      return this.mailToWGPublicList + fragment;
    },
    get mailToWGPublicListSubscription() {
      return `mailto:${this.wgPublicList}-request@w3.org?subject=subscribe`;
    },
    get isUnofficial() {
      return this.specStatus === "unofficial";
    },
    get logos() {
      if (this.isUnofficial && !Array.isArray(conf.logos)) {
        return [];
      }
      if (this.isSubmission) {
        const logos = conf.logos.slice();
        if (this.isMemberSubmission) {
          const memSubmissionLogo = {
            alt: "W3C Member Submission",
            href: "https://www.w3.org/Submission/",
            src: "https://www.w3.org/Icons/member_subm-v.svg",
            width: "211",
          };
          logos.push({ ...baseLogo, ...memSubmissionLogo });
        }
        if (this.isTeamSubmission) {
          const teamSubmissionLogo = {
            alt: "W3C Team Submission",
            href: "https://www.w3.org/TeamSubmission/",
            src: "https://www.w3.org/Icons/team_subm-v.svg",
            width: "211",
          };
          logos.push({ ...baseLogo, ...teamSubmissionLogo });
        }
        return logos;
      }
      return conf.logos;
    },
    get isCCBY() {
      return this.license === "cc-by";
    },
    get isW3CSoftAndDocLicense() {
      return this.license === "w3c-software-doc";
    },
    get licenseInfo() {
      return licenses[this.license];
    },
    get isCGBG() {
      return cgbg.includes(this.specStatus);
    },
    get isCGFinal() {
      return this.isCGBG && this.specStatus.endsWith("G-FINAL");
    },
    get isBasic() {
      return this.specStatus === "base";
    },
    get isRegular() {
      return !this.isCGBG && !this.isBasic;
    },
    get title() {
      return document.title || "No Title";
    },
    get subtitle() {
      return conf.subtitle || "";
    },
    get publishYear() {
      return this.publishDate.getUTCFullYear();
    },
    get publishHumanDate() {
      return W3CDate.format(this.publishDate);
    },
    get isNoTrack() {
      return noTrackStatus.includes(this.specStatus);
    },
    get isRecTrack() {
      return this.noRecTrack ? false : recTrackStatus.includes(this.specStatus);
    },
    get isMemberSubmission() {
      return this.specStatus === "Member-SUBM";
    },
    get isTeamSubmission() {
      return this.specStatus === "Team-SUBM";
    },
    get isSubmission() {
      return this.isMemberSubmission || this.isTeamSubmission;
    },
    get anOrA() {
      return precededByAn.includes(this.specStatus) ? "an" : "a";
    },
    get isTagFinding() {
      return (
        this.specStatus === "finding" || this.specStatus === "draft-finding"
      );
    },
    get maturity() {
      return status2maturity[this.specStatus] || this.specStatus;
    },
    get publishSpace() {
      if (this.specStatus === "Member-SUBM") return "Submission";
      else if (this.specStatus === "Team-SUBM") return "TeamSubmission";
      return "TR";
    },
    get thisVersion() {
      if (this.isRegular) {
        return (
          "https://www.w3.org/" +
          this.publishSpace +
          "/" +
          this.publishDate.getUTCFullYear() +
          "/" +
          this.maturity +
          "-" +
          this.shortName +
          "-" +
          concatDate(this.publishDate) +
          "/"
        );
      }
      if (this.specStatus === "ED") {
        return this.edDraftURI;
      }
      if (this.isTagFinding) {
        return "https://www.w3.org/2001/tag/doc/" + this.shortName;
      }
      return conf.thisVersion;
    },
    get latestVersion() {
      if (this.isRegular) {
        return (
          "https://www.w3.org/" + this.publishSpace + "/" + this.shortName + "/"
        );
      }
      if (this.isTagFinding) {
        return conf.latestVersion + "-" + ISODate.format(this.publishDate);
      }
      return conf.latestVersion;
    },
    get prevVersion() {
      if (!this.previousPublishDate) {
        return this.prevVersion || "";
      }
      if (this.isTagFinding) {
        return (
          this.latestVersion + "-" + ISODate.format(this.previousPublishDate)
        );
      } else if (this.isCGBG) {
        return this.prevVersion || "";
      } else if (this.isBasic) {
        return "";
      }
      const pmat = status2maturity[this.previousMaturity]
        ? status2maturity[this.previousMaturity]
        : this.previousMaturity;
      return (
        "https://www.w3.org/TR/" +
        this.previousPublishDate.getUTCFullYear() +
        "/" +
        pmat +
        "-" +
        this.shortName +
        "-" +
        concatDate(this.previousPublishDate) +
        "/"
      );
    },
    get prevRecURI() {
      if (this.prevRecShortname && !conf.prevRecURI) {
        return "https://www.w3.org/TR/" + this.prevRecShortname;
      }
      return conf.prevRecURI;
    },
    get multipleEditors() {
      return this.editors && this.editors.length > 1;
    },
    get multipleFormerEditors() {
      return Array.isArray(this.formerEditors) && this.formerEditors.length > 1;
    },
    get multipleAuthors() {
      return this.authors && this.authors.length > 1;
    },
    get multipleAlternates() {
      return this.alternateFormats && this.alternateFormats.length > 1;
    },
    get alternatesHTML() {
      return (
        this.alternateFormats &&
        joinAnd(this.alternateFormats, alt => {
          let optional =
            alt.hasOwnProperty("lang") && alt.lang
              ? " hreflang='" + alt.lang + "'"
              : "";
          optional +=
            alt.hasOwnProperty("type") && alt.type
              ? " type='" + alt.type + "'"
              : "";
          return (
            "<a rel='alternate' href='" +
            alt.uri +
            "'" +
            optional +
            ">" +
            alt.label +
            "</a>"
          );
        })
      );
    },
    get bugTrackerHTML() {
      if (!this.bugTracker) {
        return "";
      }
      if (this.bugTracker.new && this.bugTracker.open) {
        return (
          "<a href='" +
          this.bugTracker.new +
          "'>" +
          this.l10n.file_a_bug +
          "</a> " +
          this.l10n.open_parens +
          "<a href='" +
          this.bugTracker.open +
          "'>" +
          this.l10n.open_bugs +
          "</a>" +
          this.l10n.close_parens
        );
      } else if (this.bugTracker.open) {
        return "<a href='" + this.bugTracker.open + "'>open bugs</a>";
      } else if (this.bugTracker.new) {
        return "<a href='" + this.bugTracker.new + "'>file a bug</a>";
      }
      return "";
    },
    get copyrightStart() {
      if (conf.copyrightStart && conf.copyrightStart == this.publishYear) {
        return "";
      }
      return conf.copyrightStart;
    },
    get longStatus() {
      return status2long[this.specStatus];
    },
    get textStatus() {
      return status2text[this.specStatus];
    },
    get rdfStatus() {
      return status2rdf[this.specStatus];
    },
    get showThisVersion() {
      return !this.isNoTrack || this.isTagFinding;
    },
    get showPreviousVersion() {
      if (this.specStatus.endsWith("NOTE") && !this.prevVersion) {
        return false;
      }
      if (this.isTagFinding) {
        return !!this.previousPublishDate;
      }
      return (
        this.specStatus !== "FPWD" &&
        this.specStatus !== "FPLC" &&
        this.specStatus !== "ED" &&
        !this.isNoTrack &&
        !this.isSubmission
      );
    },
    get notYetRec() {
      return this.isRecTrack && this.specStatus !== "REC";
    },
    get isRec() {
      return this.isRecTrack && this.specStatus === "REC";
    },
    get notRec() {
      return this.specStatus !== "REC";
    },
    get prependW3C() {
      return !this.isUnofficial;
    },
    get isED() {
      return this.specStatus === "ED";
    },
    get isCR() {
      return this.specStatus === "CR";
    },
    get isPR() {
      return this.specStatus === "PR";
    },
    get isPER() {
      return this.specStatus === "PER";
    },
    get isMO() {
      return this.specStatus === "MO";
    },
    get isNote() {
      return ["FPWD-NOTE", "WG-NOTE"].includes(this.specStatus);
    },
    get isIGNote() {
      return this.specStatus === "IG-NOTE";
    },
    get dashDate() {
      return ISODate.format(this.publishDate);
    },
    get publishISODate() {
      return this.publishDate.toISOString();
    },
    get shortISODate() {
      return ISODate.format(this.publishDate);
    },
    get wgId() {
      if (!this.wgPatentURI) {
        return "";
      }
      // it's always at "pp-impl" + 1
      const urlParts = this.wgPatentURI.split("/");
      const pos = urlParts.findIndex(item => item === "pp-impl") + 1;
      return urlParts[pos] || "";
    },
    get multipleWGs() {
      return Array.isArray(this.wg) && this.wg.length > 1;
    },
    get wgHTML() {
      if (!Array.isArray(this.wg)) {
        return "the <a href='" + this.wgURI + "'>" + this.wg + "</a>";
      }
      return joinAnd(
        this.wg,
        (wg, idx) => "the <a href='" + this.wgURI[idx] + "'>" + wg + "</a>"
      );
    },
    get wgPatentHTML() {
      const pats = [];
      for (let i = 0, n = this.wg.length; i < n; i++) {
        pats.push(
          "a <a href='" +
            this.wgPatentURI[i] +
            "' rel='disclosure'>" +
            "public list of any patent disclosures  (" +
            this.wg[i] +
            ")</a>"
        );
      }
      return joinAnd(pats);
    },
    get humanCREnd() {
      return W3CDate.format(this.crEnd);
    },
    get humanPREnd() {
      return W3CDate.format(this.prEnd);
    },
    get humanPEREnd() {
      return W3CDate.format(this.perEnd);
    },
    get recNotExpected() {
      return conf.recNotExpected
        ? true
        : !this.isRecTrack &&
            this.maturity == "WD" &&
            this.specStatus !== "FPWD-NOTE";
    }
  };
  // TODO: use object spread on top of the options object
  // after https://github.com/babel/babel/issues/9322
  for (const [key, value] of Object.entries(conf)) {
    if (!(key in options)) {
      options[key] = value;
    }
  }
  return options;
}

/**
 * @param {*} conf
 * @param {string} prop
 * @param {string | number | Date} fallbackDate
 */
function validateDateAndRecover(conf, prop, fallbackDate = new Date()) {
  const date = conf[prop] ? new Date(conf[prop]) : new Date(fallbackDate);
  // if date is valid
  if (Number.isFinite(date.valueOf())) {
    const formattedDate = ISODate.format(date);
    return new Date(formattedDate);
  }
  const msg =
    `[\`${prop}\`](https://github.com/w3c/respec/wiki/${prop}) ` +
    `is not a valid date: "${conf[prop]}". Expected format 'YYYY-MM-DD'.`;
  pub("error", msg);
  return new Date(ISODate.format(new Date()));
}

function validateConfigurationAndTryRecover(options) {
  if (["cc-by"].includes(options.license)) {
    const msg =
      `You cannot use license "\`${options.license}\`" with W3C Specs. ` +
      'Please set `respecConfig.license: "w3c-software-doc"` instead.';
    pub("error", msg);
  }
  if (!options.specStatus) {
    pub("error", "Missing required configuration: `specStatus`");
  }
  if (options.isRegular && !options.shortName) {
    pub("error", "Missing required configuration: `shortName`");
  }
  if (options.testSuiteURI) {
    const url = new URL(options.testSuiteURI, location.href);
    const { host, pathname } = url;
    if (
      host === "github.com" &&
      pathname.startsWith("/w3c/web-platform-tests/")
    ) {
      const msg =
        "Web Platform Tests have moved to a new Github Organization at https://github.com/web-platform-tests. " +
        "Please update your [`testSuiteURI`](https://github.com/w3c/respec/wiki/testSuiteURI) to point to the " +
        `new tests repository (e.g., https://github.com/web-platform-tests/wpt/${
          options.shortName
        } ).`;
      pub("warn", msg);
    }
  }
  options.publishDate = validateDateAndRecover(
    options,
    "publishDate",
    document.lastModified
  );
  if (!options.edDraftURI && options.specStatus === "ED") {
    pub("warn", "Editor's Drafts should set edDraftURI.");
  }
  if (options.previousPublishDate) {
    if (!options.previousMaturity && !options.isTagFinding) {
      pub("error", "`previousPublishDate` is set, but not `previousMaturity`.");
    }

    options.previousPublishDate = validateDateAndRecover(
      options,
      "previousPublishDate"
    );
  } else if (
    !options.specStatus.endsWith("NOTE") &&
    options.specStatus !== "FPWD" &&
    options.specStatus !== "FPLC" &&
    options.specStatus !== "ED" &&
    !options.noRecTrack &&
    !options.isNoTrack &&
    !options.isSubmission
  ) {
    pub(
      "error",
      "Document on track but no previous version:" +
        " Add `previousMaturity`, and `previousPublishDate` to ReSpec's config."
    );
  }
  if (!options.editors || options.editors.length === 0) {
    pub("error", "At least one editor is required");
  }
  const peopCheck = it => {
    if (!it.name) pub("error", "All authors and editors must have a name.");
  };
  if (options.editors) {
    options.editors.forEach(peopCheck);
  }
  if (options.formerEditors) {
    options.formerEditors.forEach(peopCheck);
  }
  if (options.authors) {
    options.authors.forEach(peopCheck);
  }
  (options.alternateFormats || []).forEach(it => {
    if (!it.uri || !it.label) {
      pub("error", "All alternate formats must have a uri and a label.");
    }
  });
  if (options.isRec && !options.errata) {
    pub("error", "Recommendations must have an errata link.");
  }
  if (options.specStatus === "PR" && !options.crEnd) {
    pub(
      "error",
      `\`specStatus\` is "PR" but no \`crEnd\` is specified (needed to indicate end of previous CR).`
    );
  }
  if (options.specStatus === "CR" && !options.crEnd) {
    pub(
      "error",
      `\`specStatus\` is "CR", but no \`crEnd\` is specified in Respec config.`
    );
  }
  options.crEnd = validateDateAndRecover(options, "crEnd");
  if (options.specStatus === "PR" && !options.prEnd) {
    pub("error", `\`specStatus\` is "PR" but no \`prEnd\` is specified.`);
  }
  options.prEnd = validateDateAndRecover(options, "prEnd");
  if (options.specStatus === "PER" && !options.perEnd) {
    pub("error", "Status is PER but no perEnd is specified");
  }
  options.perEnd = validateDateAndRecover(options, "perEnd");

  // NOTE:
  //  When arrays, wg and wgURI have to be the same length (and in the same order).
  //  Technically wgURI could be longer but the rest is ignored.
  //  However wgPatentURI can be shorter. This covers the case where multiple groups
  //  publish together but some aren't used for patent policy purposes (typically this
  //  happens when one is foolish enough to do joint work with the TAG). In such cases,
  //  the groups whose patent policy applies need to be listed first, and wgPatentURI
  //  can be shorter — but it still needs to be an array.
  const wgPotentialArray = [options.wg, options.wgURI, options.wgPatentURI];
  if (
    wgPotentialArray.some(item => Array.isArray(item)) &&
    !wgPotentialArray.every(item => Array.isArray(item))
  ) {
    pub(
      "error",
      "If one of '`wg`', '`wgURI`', or '`wgPatentURI`' is an array, they all have to be."
    );
  }
  if (options.isCGBG && !options.wg) {
    pub(
      "error",
      "[`wg`](https://github.com/w3c/respec/wiki/wg)" +
        " configuration option is required for this kind of document."
    );
  }
  if (options.isIGNote && !options.charterDisclosureURI) {
    pub(
      "error",
      "IG-NOTEs must link to charter's disclosure section using `charterDisclosureURI`."
    );
  }
  if (!options.implementationReportURI && options.isCR) {
    pub(
      "error",
      "CR documents must have an [`implementationReportURI`](https://github.com/w3c/respec/wiki/implementationReportURI) " +
        "that describes [implementation experience](https://www.w3.org/2018/Process-20180201/#implementation-experience)."
    );
  }
  if (!options.implementationReportURI && options.isPR) {
    pub(
      "warn",
      "PR documents should include an " +
        " [`implementationReportURI`](https://github.com/w3c/respec/wiki/implementationReportURI)" +
        " that describes [implementation experience](https://www.w3.org/2018/Process-20180201/#implementation-experience)."
    );
  }
}

export function run(conf) {
  const options = createTemplateOptions(conf);
  validateConfigurationAndTryRecover(options);

  // insert into document
  const header = (options.isCGBG ? cgbgHeadersTmpl : headersTmpl)(options);
  document.body.prepend(header);
  document.body.classList.add("h-entry");

  // handle SotD
  const sotd =
    document.getElementById("sotd") || document.createElement("section");
  if (
    (options.isCGBG || !options.isNoTrack || options.isTagFinding) &&
    !sotd.id
  ) {
    pub(
      "error",
      "A custom SotD paragraph is required for your type of document."
    );
    sotd.id = "sotd";
  }
  sotd.classList.add("introductory");

  hyperHTML.bind(sotd)`${populateSoTD(options, sotd)}`;

  // Requested by https://github.com/w3c/respec/issues/504
  // Makes a record of a few auto-generated things.
  pub("amend-user-config", {
    publishISODate: options.publishISODate,
    generatedSubtitle: `${options.longStatus} ${options.publishHumanDate}`,
  });
}

/**
 * @param {*} options
 * @param {HTMLElement} sotd
 */
function populateSoTD(options, sotd) {
  Object.assign(options, collectSotdContent(sotd, options));
  const template = options.isCGBG ? cgbgSotdTmpl : sotdTmpl;
  return template(options);
}

/**
 * @param {HTMLElement} sotd
 */
function collectSotdContent(sotd, { isTagFinding = false }) {
  const sotdClone = sotd.cloneNode(true);
  const additionalContent = document.createDocumentFragment();
  // we collect everything until we hit a section,
  // that becomes the custom content.
  while (sotdClone.hasChildNodes()) {
    if (
      !isElement(sotdClone.firstChild) ||
      sotdClone.firstChild.localName !== "section"
    ) {
      additionalContent.appendChild(sotdClone.firstChild);
      continue;
    }
    break;
  }
  if (isTagFinding && !additionalContent.hasChildNodes()) {
    pub(
      "warn",
      "ReSpec does not support automated SotD generation for TAG findings, " +
        "please add the prerequisite content in the 'sotd' section"
    );
  }
  return {
    additionalContent,
    // Whatever sections are left, we throw at the end.
    additionalSections: sotdClone.childNodes,
  };
}

/**
 * @param {Node} node
 * @return {node is Element}
 */
function isElement(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
